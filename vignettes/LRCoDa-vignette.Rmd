---
title: "LRCoDa-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{LRCoDa-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1. Load Dependencies

```{r setup, message=FALSE, warning=FALSE}
library(LRCoDa)
library(robCompositions)
library(dplyr)
library(sjmisc)
library(robustbase)
library(forcats)
```

## 2. Load data

Load dataset "gemas" from the package `robCompositions` and recode one level from "" to "Not Specified", since the `LRCoDa` function does not allow empty names for the levels.

```{r}
data("gemas")

gemas <- gemas %>% 
  mutate(soilclass = fct_recode(soilclass, "Not specified" = ""))
```

## 3. Introduction of usage of the factor variable extension with LRCoDa

With the newly released package `LRCoDa` we are able to use factor variables for the linear regression on raw compositional data. As in the function `lmCoDaX` from the package `robCompositions` we have the option between the "robust" and "classical" method.

First, we show an example where we use the robust method on the dataset "gemas" and use the "soilclass" as the factor variable, the trace elements as composition and "sand" as the target variable.

```{r, message=FALSE}
X <- dplyr::select(gemas, c(soilclass, Al:Zr))
y <- gemas$sand
LR_robust_1 <- LRCoDa(y = y, X = X, factor_column = 'soilclass', method = 'robust', 
                      max_refinement_steps = 500)
LR_robust_1$ilr
```

We can access the summary output of the Linear Regression as known from the function `lmCoDaX` with \$ilr (for the ilr output) and \$lm (for the lm output). Furthermore, we can also clearly identify through the prefix of the variables which is the factor variable and which are the variables from the composition. 

The output for the robust method looks differently to the output from the `lmCoDaX` function, since we use `lmrob` for the robust calculation of the linear regression in `LRCoDa` instead of `ltsReg` in `lmCoDaX`.

### 3.1. Limitations of the factor variable usage

We list a few scenarios in which we illustrate the limitations of the factor variable usage.

#### 3.1.1. More than one factor variable is not allowed

We only can use one factor variable for the model. We return an error message when more than one factor variable is used.

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(soilclass, COUNTRY, Al:Zr))
LRCoDa(y = gemas$sand, X = X, factor_column = c('COUNTRY', 'soilclass'))
```

#### 3.1.2. Only characters and factors are allowed as datatype for the factor variable

We only allow character and factor as datatypes for the factor variable for the model. We return an error message when a numerical values are contained in the factor variable.

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, Al:Zr))
LRCoDa(y = gemas$sand, X = X, factor_column = c('MeanTemp'))
```

#### 3.1.3. The factor has to be specified

When the factor column is not specified in the function input, but X contains a variable with factors or characters the function returns an error message that "X contains non-numerical variables but there is no factor_column defined".

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(soilclass, Al:Zr))
LRCoDa(y = gemas$sand, X = X)
```

#### 3.1.4. Factor column has to be specified as name in the function input

The factor column has to be specified exactly like in the help function described. It is not possible to fill in the whole column.

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(soilclass, Al:Zr))
LRCoDa(y = gemas$sand, X = X, factor_column = X %>% select(soilclass))
```

## 4. Introduction of usage of the external variable extension with LRCoDa

With the newly released package `LRCoDa` we are also able to use external variables, which are not part of the composition. We have here also the option between the "robust" and "classical" method and we can combine it with a factor variable.

We show an example where we combine external variables with a factor variables and of course the composition (naming as internal variables). We use the "gemas" dataset, where "MeanTemp" the external variable is, "soilclass" the factor variable, the trace elements the composition ("Internal" variables) and "sand" the target variable.

```{r, message=FALSE}
X <- dplyr::select(gemas, c(MeanTemp, soilclass, Al:Zr))
y <- gemas$sand
LR_robust_2 <- LRCoDa(y = y, X = X, external = c('MeanTemp'), factor_column = 'soilclass', 
                      method = 'robust', max_refinement_steps = 500)
LR_robust_2$ilr
```

We can observe here that all the different types of variable have the different prefix, where we can identify them without any problem.

### 4.1 Possibilities and Limitations of the external variable usage

We list the possibilities and the limitations of the external variable usage.

#### 4.1.1. Multiple external variables are allowed and supported

We allow and support the usage of multiple external variables in the same model.

```{r, error=TRUE, message=FALSE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, AnnPrec, Al:Zr))
LRCoDa(y = gemas$sand, X = X, external = c('MeanTemp', 'AnnPrec'), 
       method = "classical")
```

#### 4.1.2. Only numerical variables are allowed as External variables

We allow only numerical variables for the external variables, since non-numerical variables are captured with the factor variables. We return an error message that "X contains non-numerical variables but there is no factor_column defined".

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, AnnPrec, COUNTRY, Al:Zr))
LRCoDa(y = gemas$sand, X = X, external = c('MeanTemp', 'AnnPrec', 'COUNTRY'), 
       method = 'classical')
```

#### 4.1.3. External column has to be specified as name in the function input

The external column has to be specified exactly like in the help function described. It is not possible to fill in the whole column.

```{r, error=TRUE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, AnnPrec, Al:Zr))
LRCoDa(y = gemas$sand, X = X, external = X %>% select(c('MeanTemp', 'AnnPrec')))
```

## 5. Use of lmrob for robust fitting

With the newly introduced factor variable usage for the linear regression on raw compositional data, we have to change the fitting algorithm from the old `ltsReg` (used in `lmCoDaX`) to `lmrob` (used in `LRCoDa`). This change offers a lot of advantages when working with factor variables and also with external variables in comparison to `ltsReg` which is very limited for this application.
Furthermore, `lmrob` determines robustness weights between 0 and 1, whereas `ltsReg` works only with 0 and 1 for the robustness weigths. However, there are also new challenges introduced with `lmrob`, as illustrated in the example below. Also the backwards compatibility of the function when fitting with the robust method is not given because of this change.

```{r, error=TRUE, message=FALSE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, AnnPrec, soilclass, Al:Zr))
LRCoDa(y = gemas$sand, X = X, external = c('MeanTemp', 'AnnPrec'), 
       factor_column = c('soilclass'), max_refinement_steps = 200)
```

The algorithm does not converge with the default refinement steps 200 as defined in the `lmrob` function. Therefore we added the max_refinement_steps parameter directly in the function input in `LRCoDa`.

```{r, error=TRUE, message=FALSE, out.width=60}
X <- dplyr::select(gemas, c(MeanTemp, AnnPrec, soilclass, Al:Zr))
LRCoDa(y = gemas$sand, X = X, external = c('MeanTemp', 'AnnPrec'), 
       factor_column = c('soilclass'), max_refinement_steps = 500)
```

And now with max_refinement_steps set to 500 the algorithm converge.

## 6. Further improvements

The norm of the pivot coordinates calculation can now also be defined in the function input, in contrast to the `lmCoDaX` function. The default value is "orthonorm" as it is the default in the `pivotCoord` function and therefore used in `lmCoDaX`.

```{r, error=TRUE, message=FALSE, out.width=60}
X <- dplyr::select(gemas, c(Al:Zr))
LRCoDa(y = gemas$sand, X = X, pivot_norm = "orthogonal", method = "classical")
```
